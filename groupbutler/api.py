"""
the api contains the telegram API interface
"""
from typing import Dict, List, Any
from prometheus_client import Histogram
from prometheus_async.aio import time as prom_time
import aiohttp

from .message import Message

DEFAULT_ENDPOINT = "https://api.telegram.org/"

REQUEST_TIME = Histogram("api_request_time_seconds",
                         "time taken by telegram API request",
                         ["method"])

JSONObj = Dict[str, Any]

class TelegramError(aiohttp.ClientError):
    """Exception raised when errors occur interacting with the telegram API"""

def make_api_get_method(method, description="", return_type=Any):
    """create a standard GET method with no special handling"""
    async def _inner_function(self, **args) -> return_type:
        async with self.get(method, params=args) as resp:
            resp_json = await resp.json()
            if resp_json["ok"] is False:
                raise TelegramError(resp_json)

            return resp_json["result"]

    _inner_function.__name__ = method
    if description == "":
        _inner_function.__doc__ = "autogenerated method for " + method
    else:
        _inner_function.__doc__ = description

    # We need to apply the decorator manually, because we need to rename the
    # function before that
    return prom_time(REQUEST_TIME.labels(method))(_inner_function)

def make_api_post_method(method, description="", return_type=Any):
    """create a standard GET method with no special handling"""
    async def _inner_function(self, **args) -> return_type:
        async with self.post(method, json=args) as resp:
            resp_json = await resp.json()
            if resp_json["ok"] is False:
                raise TelegramError(resp_json)

            return resp_json["result"]

    _inner_function.__name__ = method
    if description == "":
        _inner_function.__doc__ = "autogenerated method for " + method
    else:
        _inner_function.__doc__ = "description"

    # We need to apply the decorator manually, because we need to rename the
    # function before that
    return REQUEST_TIME.labels(method).time()(_inner_function)

class TelegramAPI():
    """The TelegramAPI object is used to send requests to the Telegram bot
    API"""
    # pylint: disable=invalid-name
    def __init__(self, token: str, endpoint: str = DEFAULT_ENDPOINT):
        self.token = token
        self.endpoint = endpoint
        self._ses = None

    async def init(self):
        """we need a second init function, since __init__ can't call await"""
        self._ses = aiohttp.ClientSession()

    getMe = make_api_get_method(
        "getMe",
        description="A simple method for testing your bot's auth token",
        return_type=JSONObj)

    getUpdates = make_api_get_method(
        "getUpdates",
        description="Receive incoming updates using long polling",
        return_type=List[JSONObj])

    sendMessage = make_api_post_method(
        "sendMessage",
        description="Send text messages",
        return_type=JSONObj)

    def get(self, api_method, params=None):
        """wrapper to call the given api method, generating the URL

        (note that this wrapper is not async, so the result must be awaited
        externally)"""
        url = self.endpoint + "bot" + self.token + "/" + api_method
        # print(url)
        return self._ses.get(url, params=params)

    def post(self, api_method, json=None):
        """wrapper to call the given api method, generating the URL

        (note that this wrapper is not async, so the result must be awaited
        externally)"""
        url = self.endpoint + "bot" + self.token + "/" + api_method
        # print(url)
        return self._ses.post(url, json=json)

    async def respond_to(self, message: Message, text, **args):
        """respond to a message. This sends it to the same chat, but does not
        add reply markup """
        return await self.sendMessage(
            chat_id=message.chat_id,
            text=text,
            **args
        )

    async def reply_to(self, message: Message, text: str, **args):
        """reply to a message directly"""
        return await self.respond_to(
            message,
            text,
            reply_to_message_id=message.msg_id,
            **args
        )

    async def respond_to_sender_in_pm(self, message: Message, text: str, **args):
        """respond to the sender of a message in the private chat"""
        return await self.sendMessage(
            chat_id=message.from_id,
            text=text,
            **args
        )
